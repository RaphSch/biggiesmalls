# include <vector>
# include <chrono>
# include <random>
# include <iostream>
# include <cassert>
# include <exception>
# include <array>

using namespace std;

// GLOBAL PARAMETERS

const int N = 100; // Initial population size
const int S = 100; // Island size (number of patches on the island)
const int maxTime = 10000; // Max duration of the simulation
const int maxSampling = 1000; // Max number of times for resampling a body size if the result was negative or too low

const double meanSize0 = 2.0; // Mean body size in the mainland (source) population
const double stdSize0 = 0.1; // Standard deviation of body size on the mainland
const double minBodySize = 0.1; // Minimum body size allowed

const int deathAge = 0; // Lifespan of the preys (generations)
const int deathAgePredators = 1; // Lifespan of the predators (generations)

const int    initPredatorDensity = 10; // Initial popultion size of the predators
const double killConversion = 1.5; // Proportion of a killed prey that produces predator offspring

const double alpha = 1.0; // Parameter tuning the dependency of competition on body size
const double beta = 0.5; // Parameter tuning the dependency of reproduction on body size
const double dGamma = 1.0; // Parameter tuning the dependency of predation on body size
const double epsilon = 4.0; // Scaling parameter for offspring reproduction
const double kappa = 0.5; // Basal number of offspring of the preys when reproduction is size independent

const double mutationalVariance = 0.2; // Standard deviation of the normal distribution describing mutational effects
const double mutationRate = 0.5; // Mutation rate (generation-1)

bernoulli_distribution mutationEvent(mutationRate); // Distribution in which to draw mutation events
normal_distribution <double> bodySizeDistribution(meanSize0, stdSize0); // Distribution in which to draw body sizes
normal_distribution <double> mutation(0.0, mutationalVariance); // Distribution in which to draw mutational effects
// Note: mutation std = 0.5 allows to go from values around 3.0 at gen0 to ~15.0 at gen1000


// RANDOM NUMBER GENERATOR

mt19937_64 rng;

// CLASSES

// Class of individuals
struct ind {
    double  size = 0;
    bool    hasFood = false;
    int     age = 0;
    bool isEaten = false;
};

// ACCESSORY FUNCTION

// Function to shuffle a vector
void shuffleVector(vector<ind> &vec, mt19937_64 &rng) {
    
    // For each position in the vector (starting from the end)...
    for (int i = vec.size() - 1; i > 0; --i) {
        
        // Create a distribution of random numbers between 0 and i
        uniform_int_distribution<int> randomNumber(0, i);
        
        // Draw a random position placed before it in the vector
        int j = randomNumber(rng);
        assert(j <= i);
        assert(j >= 0);
        
        // Swap the two positions
        ind tmp = vec[i];
        vec[i] = vec[j];
        vec[j] = tmp;
        
    }
    
}

// Function to determine the litter size of an individual
int getNbOffspring(const double &parentSize) {
    
    double meanNbOffspring = (beta / parentSize + (1.0 - beta) * kappa) * epsilon;
    
    poisson_distribution<int> offspringDistribution(meanNbOffspring);
    int nbOffspring = offspringDistribution(rng);
    
    if (nbOffspring > 10)
        nbOffspring = 10;
    
    return nbOffspring;
    
}


// MAIN FUNCTION

int main(int argc, char* argv[]) {
    
    try {
        
        if (meanSize0 <= 0.0)
            throw runtime_error("meanSize cannot be zero or negative");
        if (stdSize0 <= 0.0)
            throw runtime_error("stdSize cannot be zero or negative");
        if (minBodySize < 0.0)
            throw runtime_error("minimal body size cannot be negative");
        
        // Set random seed
        auto tp = chrono::high_resolution_clock::now();
        unsigned seed = static_cast<unsigned>(tp.time_since_epoch().count());
        rng.seed(seed);
        
        // Declare an initial population of N individuals
        vector <ind> population(N);
        assert(population.size() == N);
        
        // Initialize size of individuals from normal distribution with given mean and standard deviation
        for (int i = 0; i < population.size(); ++i) {
            int a = 0;
            do {
                population[i].size = bodySizeDistribution(rng);
                ++a;
                // If the size of an individual is too small, redraw it (the normal distribution is truncated in zero)
                // but not too many times
            } while (population[i].size <= minBodySize && a < maxSampling);
            if (population[i].size < minBodySize)
                throw runtime_error("negative values of body size were generated");
            // cout << population[i].size << ' ';
        }
        // cout << endl;
        
        // Initialize predator population
        if (initPredatorDensity < 0)
            throw runtime_error("initial density of predators cannot be negative");
        if (deathAgePredators <= 0)
            throw runtime_error("death rate of predators must be at least one year");
        
        int nPredators = initPredatorDensity;
        bool isExtinctPredator = initPredatorDensity == 0 ? true : false;
        
        vector<int> birthRecord(deathAgePredators,0); // vector recording number of predator born in the last <predator lifespan> years
        birthRecord.back() = initPredatorDensity; // THEO <16/12>
        assert(birthRecord.size() == deathAgePredators);
        
        if (initPredatorDensity == 0)
            cout << "Simulation with no predators" << endl;
        
        
        // Generation step loop
        for (int t = 1; t <= maxTime; ++t) {
            
            //cout << t << endl;
            
            // Check if there still are individuals in the population
            if (population.empty()) {
                cerr << "Generation " << t << ": population went extinct\n";
                exit(EXIT_SUCCESS);
            }
            
            
            // Declare the number of food patches available as defined by island surface
            // foodPatches is a vector of subvectors: each subvector says which individuals are on the patch
            array <vector<int>, S> foodPatches;
            assert(foodPatches.size() == S);
            
            
            
            // (Re)Shuffling the population vector
            shuffleVector(population, rng);
            
            
            // 1 - ASSIGNING INDIVIDUALS TO FOOD PATCHES
            for (int i = 0; i < population.size(); ++i) {
                foodPatches[i % S].push_back(i);
            }
            
        
            // 2 - PREDATION
            
            // Vector of survivors of predation
            vector<ind> survivors;
            
            int nKills = 0;
            if (!isExtinctPredator) {
                
                // Every predator picks a patch at random, and if preys are present, eats one
                for (int j = 0; j < nPredators; ++j) {
                    
                    // Pick a patch
                    uniform_int_distribution<int> pickPatch(0, S - 1);
                    int patch = pickPatch(rng);
                    assert(patch >= 0 && patch <= S - 1);
                    
                    int prey;
                    
                    // If there is one individual on that patch, eat it
                    if (foodPatches[patch].size() >= 1) {
                        if (foodPatches[patch].size() == 1)
                            prey = 0;
                        
                        // If there are more...
                        else if (foodPatches[patch].size() > 1) {
                            
                            // Probabilities of each individual in the patch to be caught, depending on body size (or not if gamma = 0)
                            vector<double> probCatch(foodPatches[patch].size());
                            assert(probCatch.size() == foodPatches[patch].size());
                            double sum = 0.0;
                            for (int i = 0; i < foodPatches[patch].size(); ++i) {
                                probCatch[i] = pow(population[foodPatches[patch][i]].size, exp(dGamma) - 1.0);
                                sum += probCatch[i];
                            }
                            for (int i = 0; i < foodPatches[patch].size(); ++i) {
                                // normalize probabilities
                                probCatch[i] /= sum;
                                assert(probCatch[i] >= 0.0 && probCatch[i] <= 1.0);
                            }
                            
                            // Pick a random prey
                            discrete_distribution<int> pickPrey(probCatch.begin(), probCatch.end());
                            prey = pickPrey(rng);
                            assert(prey >= 0 && prey < foodPatches[patch].size());
                        }
                        
                        // Prey is eaten
                        population[foodPatches[patch][prey]].isEaten = true;
                        
                        // Prey is removed from the patch
                        vector <int> patchSurvivors;
                        for (int i = 0; i < foodPatches[patch].size(); ++i)
                            if (i != prey)
                                patchSurvivors.push_back(i);
                        assert(patchSurvivors.size() == foodPatches[patch].size() - 1);
                        
                        foodPatches[patch] = patchSurvivors;
                        
                        // Update the number of kills
                        ++nKills;
                    }
                    
                } // end of loop through predators
                
                // Population will be updated later (otherwise competition step bugs)
                
            } // end of predation
            
            cout << "Number of prey killed: " << nKills << endl;
            
            
            
            // 3 - ASYMETRIC COMPETITION
            // For each patch...
            for (int p = 0; p < foodPatches.size(); ++p) {
                
                // If that patch is occupied by more than one indiv, then competition happens
                if (foodPatches[p].size() > 1) {
                    
                    // Probabilities of each individual in the patch to win, depending on body size(or not if alpha = 0)
                    vector<double> probWin(foodPatches[p].size());
                    assert(probWin.size() == foodPatches[p].size());
                    double sum = 0.0;
                    for (int i = 0; i < foodPatches[p].size(); ++i) {
                        probWin[i] = pow(population[foodPatches[p][i]].size, exp(alpha) - 1.0);
                        sum += probWin[i];
                    }
                    for (int i = 0; i < foodPatches[p].size(); ++i) {
                        probWin[i] /= sum;
                        assert(probWin[i] >= 0.0 && probWin[i] <= 1.0);
                    }
                    
                    // Draw the outcome of competition
                    discrete_distribution<int> competitionEvent(probWin.begin(), probWin.end());
                    const int competitionOutcome = competitionEvent(rng);
                    int iWinner = foodPatches[p][competitionOutcome];
                    
                    // The winner receives the food
                    for (int j = 0; j < foodPatches[p].size(); ++j)
                        population[foodPatches[p][j]].hasFood = foodPatches[p][j] == iWinner ? true : false;
                    
                }
                
                // If only one individual, then it takes the food
                else if (foodPatches[p].size() == 1) {
                    population[foodPatches[p][0]].hasFood = true;
                }
                
            }
            
            
            // Who survived?
            for (int i = 0; i < population.size(); ++i) {
                if (!population[i].isEaten)
                    survivors.push_back(population[i]);
            }
            assert(survivors.size() <= population.size());
            
            // Only survivors of predation remain in the population
            population = survivors;
            
            
            // 4 - REPRODUCTION OF PREYS
            
            // Identify current breeding individuals
            int iCurrentPop = population.size();
            //cout << "Gen" << t << " population size = " << iCurrentPop << endl;
            vector <ind> populationNew; // <THEO 12/12>
            
            for (int i = 0; i < iCurrentPop; ++i) {
                // increment ageing <THEO 12/12>
                assert(!(population[i].age < 0) && !(population[i].age > deathAge));
                ++population[i].age;
                //cout << "Adult   of size " << population[i].size << " and " << population[i].age << " gen old" << endl;
                
                // Add breeder to the next gen population if not too old  // <THEO 12/12>
                if (population[i].age < deathAge)
                    populationNew.push_back(population[i]);
                
                // Produce a number of offspring based on size // <THEO 12/12>
                if (population[i].hasFood) {
                    
                    // expense food on offspring production
                    population[i].hasFood = false;
                    
                    int iLitterSize = getNbOffspring(population[i].size);
                    
                    for (int iOffspring = 0; iOffspring < iLitterSize; ++iOffspring) {
                        
                        // Create a new individual that is a clone of its parent with age 0
                        ind newborn = population[i];
                        newborn.age = 0;
                        
                        // Draw a mutation event // <THEO 12/12>
                        if (mutationEvent(rng)) {
                            //cout << "<MUTATION> ";
                            double mutationStep;
                            do {
                                mutationStep = mutation(rng);
                            } while (newborn.size + mutationStep < minBodySize); // constrain mutation to min size
                            newborn.size += mutationStep;
                        }
                        //cout << "Newborn of size " << newborn.size << " and " << newborn.age << " gen old" << endl;
                        // Add new individual to the next gen population
                        populationNew.push_back(newborn);  // <THEO 12/12>
                    }
                }
                // else nothing happens, no food no baby (or babies but they die right away from starvation)
                
            }
            //cout << "Gen" << t << " pop size before reproduction & death = " << iCurrentPop << endl;
            //cout << "Gen" << t << " pop size after  reproduction & death = " << populationNew.size() << endl;
            
            population = populationNew;
            
            if (population.empty()) {
                cerr << "Generation " << t << ": population went extinct\n";
                exit(EXIT_SUCCESS);
            }
            
            
            // 5 - REPRODUCTION AND DEATH OF PREDATORS
            
            if (!isExtinctPredator) {
                
                // Reproduction
                int nBabyPredators = floor(nKills * killConversion);
                assert(nBabyPredators >= 0);
                //cout << nPredators << " + " << nBabyPredators << " = ";
                nPredators += nBabyPredators;
                //cout << nPredators << endl;
                
                /*
                // If time step < predator lifespan record births every year
                if (t < deathAgePredators)
                    birthRecord[t] = nPredators;
                else {
                    
                    // Otherwise, update birth records
                    for (int j = 0; j < birthRecord.size(); ++j)
                        birthRecord[j] = (j == deathAgePredators - 1) ? nBabyPredators : birthRecord[j + 1];
                    
                    // And mortality happens
                    nPredators -= birthRecord[0]; // all predators who were born <lifespan> years ago die now
                 
                }
                */
                nPredators -= birthRecord[0];
                for (int j = 0; j < deathAgePredators - 1; ++j)
                    birthRecord[j] = birthRecord[j+1];
                birthRecord.back() = nBabyPredators;
            }
            
            
            
            // Warning if predators go extinct
            if (nPredators <= 0 && !isExtinctPredator) {
                cerr << "Generation " << t << ": predators went extinct\n";
                isExtinctPredator = true ;
            }
            
            cout << "Time " << t << ": " << population.size() << " preys and " << nPredators << " predators" << endl;
            
        } // end of loop through time steps
        
    }
    catch (exception &error) {
        cerr << "Error: " << error.what() << endl;
        exit(1);
    }
    
    
    return 0;
}
